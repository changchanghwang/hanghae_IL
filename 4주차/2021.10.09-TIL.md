W.A를 진행했다.
node.js에 대한 W.A로는 아래 사진과 같은 질문이 있었다.![](https://images.velog.io/images/changchanghwang/post/5cae97c1-de20-4013-87f6-d934901baffc/image.png)

우리팀은 질문으로 typescript에 대한 질문과 코드의 가독성에 대한 질문을 했는데 다른 질문들에 대한 대답이다.

> ### HTTP/HTTPS 프로토콜이 아닌 gRPC 프로토콜로 통신하는 서버 프로그램은 API 서버라고 부를 수 있을까요? (배포된 환경, 구현된 기능은 동일)
먼저, API(Application Programming Interface,응용 프로그래밍 인터페이스)란 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻합니다. 이러한 API를 사용하는 서버를 API서버라고 합니다. API서버는 정보를 얻거나 정보를 줄 때, 기능을 제어하기 위한 서버와 클라이언트 사이에서 어떠한 규칙이 있어야 하는데, 성능과 필요에 따라 JSON,XML 등의 규칙을 사용합니다.
한 편, gRPC는 원격 프로시저 호출을 통해 서버와 클라이언트가 소통하는 방식을 사용하는 RPC라는 프로토콜의 예 중 하나입니다. 아래 그림을 보면 알겠지만 gPRC도 Proto를 이용하여 클라이언트와 서버가 request 와 response를 주고 받고 있다는 점에서 제어를 위한 의사소통이 일어나기 때문에 API서버라고 할 수 있습니다.





> ### Sequlize같은 ORM과 MySQL같은 데이터베이스의 차이가 무엇인가요?
개념
데이터 베이스(영어: database, DB)란 여러 사람이 공유하여 사용할 목적으로 체계화해 통합, 관리하는 데이터의 집합이다. 그리고 ORM이란 Object Relational Mapping, 객체-관계 매핑으로 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것을 말합니다. ORM은 SQL 쿼리가 아닌 좀 더 직관적인 코드로 데이터를 조작하여 개발자가 객체지향 프로그래밍에 좀 더 집중할 수 있도록 해줍니다.
Node
노드에서 MySQL 작업을 쉽게 할 수 있도록 도와주는 라이브러리가 있다. 바로 시퀄라이즈 (Sequelize) 이다. 시퀄라이즈는 ORM (Object-relational Mapping) 으로 분류되며, ORM은 자바스크립트 객체와 데이터베이스의 릴레이션을 매핑해주는 도구이다. 시퀄라이즈는 MySQL 외에도 MariaDB, PostgreSQL 등등 다른 데이터베이스에도 쓸 수 있다. 문법이 어느 정도 호환되므로 프로젝트를 다른 SQL 데이터베이스로 전환할 때도 편리하다. 시퀄라이즈를 쓰는 이유는 자바스크립트 구문을 알아서 SQL로 바꿔주기 때문이다. 따라서 SQL 언어를 직접 사용하지 않더라도 자바스크립트만으로 MySQL을 조작할 수 있고, 따라서 SQL 언어를 몰라도 MySQL을 어느 정도 다룰 수 있다. 하지만 권장하지 않는다. 





> ### express.js의 라우터는 미들웨어입니다. 어떤 원리로 동작하기 때문에 미들웨어로 라우터를 구현할 수 있나요?
express에서 미들웨어 함수는 요청(request)객체, 응답(response)객체, 그리고 어플리케이션 요청-응답 사이클 도중 그 다음의 미들웨어 함수에 대한 엑세스 권한을 갖는 함수이다. 
미들웨어 함수는 요청 오브젝트(req), 응답 오브젝트 (res), 그리고 애플리케이션의 요청-응답 주기 중 그 다음의 미들웨어 함수 대한 액세스 권한을 갖는 함수입니다. 그 다음의 미들웨어 함수는 일반적으로 next라는 이름의 변수로 표시됩니다.
라우팅은 URI(또는 경로) 및 특정한 HTTP 요청 메소드(GET, POST 등)인 특정 엔드포인트에 대한 클라이언트 요청에 애플리케이션이 응답하는 방법을 결정하는 것을 말합니다.
express의 인스턴스인 app을 사용하면 라우팅을 손쉽게 해결할 수 있는데, app은 완전한 미들웨어라서 일치하는 경로를 받았을 때 파이프처럼 또다른 경로로 연결해주는 역할을 할 수 있다.

> ### Node.js에서 리팩토링시 사용하며, npm을 통해 다운로드 했던 모듈을 불러오는 require 함수는 어떻게 동작하나요? IIFE와 연결지어 찾아보고 정리해보세요.
require 메서드는 자신의 파라미터로 들어온 파일에 들어가 코드를 IIFE로 변환시킨 다음, 새로 만든 module object를 인자로 삼아 IIFE를 실행시키고, module.exports object가 변화하였다면 그 변화를 리턴값으로 그대로 가져온다. 
require method는 IIFE를 통한 encapsulation의 원리가 쓰이는데 보호하고자 하는 api들을 function expression으로 둘러싸 외부의 접근을 막되, 접근할 수 있는 방법들이 담긴 object를 리턴하는 구조이다.

> ### 불필요한 테스트코드는 무엇이며, 100개의 테스트 케이스보다 1개의 테스트 케이스가 더 효과적일 수 있는 이유는 무엇인가요?
불필요한 테스트코드는 필요없는 검증구문을 작성하게 되면 1개의 테스트케이스를 작성하는 것과 똑같은 효과를 보게 되어 100개의 테스트케이스를 작성하게 되면 오히려 자원낭비가 되어 불필요한 검증구문 100개보다 필요한 검증구문 1개가 더 효과적일 수 있다.


> ### 코딩에서 가독성의 중요성과 방향?
> 개발을 지속 가능하게 하기위해, 해당 코드의 라이프 사이클 전체의 생산성을 올려야 한다. 그 방법 중 하나가 가독성을 높혀 코드의 흐름을 빨리 캐치하는 것. 가독성이 좋은지를 판단하는 기준들 중 하나는 ‘코드를 작성하는 시간'과 ‘코드를 읽거나, 해설하는 시간' 중 어느 것이 더 오래걸리는 지 비교하고 후자가 더 짧을 수록 가독성이 높다고 판단 할 수 있다. 이러한 가독성을 높이는 코딩의 원칙 5가지를 제시한다.
코드를 변경할 때는 더 깔끔하게 만들자
기능과 코드는 필요할 때 구현해야한다. 앞으로의 예상보다 현재에 집중
설계(기능과 사양 또는 구현기법)를 단순화 해야한다.
어떤 클래스가 변경되는 이유는 딱 한 가지여야 한다.
효과가 작은 최적화는 오히려 하면 안된다. 따라서 설계 또는 프로파일링이 중요하다.

> ### 자바스크립트 타입스크립트 차이.
>자바스크립트는 스크립트 언어이며 타입스크립트는 객체지향 컴파일 언어이다.
타입스크립트는 자바스크립트의 상위 집합으로 자바스크립트의 모든 기능이 있으나 초기 설정이 불편하며 생산성이 낮아질 수 있다.
또한 모든 객체에 대해 타입을 지정해야만 하기 때문에 코드의 가독성이 떨어진다.
자바스크립트에 대해서 잘 모르고 타입스크립트에 도전하는 경우 type을 ANY로 설정하여 기존의 자바스크립트와 비슷하게 사용하는 경우가 생길 수 있어 타입스크립트를 배우기 전에 자바스크립트를 먼저 잘 하는 것을 권장한다.
또한 자바스크립트의 근본적인 오류인 this 맵핑 버그를 여전히 가지고 있어 근본적인 오류에 취약하다는 단점이 있다.
그럼에도 불구하고 협업에서 함수 인자로 전달한 값을 빠르게 찾아낼 수 있는점이나 타입에 대한 설정으로 인해 원인 모를 typeError를 방지 할 수있다는 장점이 있다


개인적으로 다른조에서 흥미로웠던 것은 아래 자료를 남기겠다.

> ### 설계 개발론 중 대표적으로 BDD(Behavior Driven Development), DDD(Domain Driven Design) 방식이 있습니다. 각각의 특징과 적용 환경은 어떻게 다를까요?
- Behavior Driven Development(BDD) - 행동 주도 개발
→ TDD(Test Driven Development), 테스트 주도 개발에서 한 반 덜 나아간 개발 방식.
→ TDD에서는 유닛 테스트로 작성 된 테스트 케이스에 대한 문서를 작성했지만, BDD는 이것을 결합 테스트와 '시나리오 테스트'까지 확장하여 각각에 해당하는 문서를 대체.
→ 시나리오는 어디서부터 테스트를 시작할지, 어떤 것을 테스트하고 어떤 것을 하지 않을지, 한 번에 얼마만큼을 테스트할지, 테스트에 어떤 이름을 붙일지, 테스트가 왜 실패했는지 등에 대한 고민을 해결해줌.
- Domain Driven Development(DDD) - 도메인 주도 개발
→ 순수한 도메인의 모델과 로직에 집중.
→ 보편적인 언어의 사용을 추구하며 모든 사람이 이해할 수 있게 문서와 코드가 동일한 표현과 단어로 구성되게 만드는 것.
→커뮤니케이션에 있어 분석 단계, 설계 단계, 구현 단계에 이르기까지 통일된 방식으로 협업이 가능.
→도메인 모델 부터 코드에 이르는 단계가 통일된 규칙을 이룸.

> ### 프로젝트 진행 시 여러명의 개발자가 투입되어 진행되므로 코드 Refactoring(리팩토링) 과정이 중요합니다.
Refactoring이란 무엇이고 장점은 무엇이 있을까요?  
1. **리팩터링을 하는 것은 유지보수에 큰 도움이 된다.**
물론 우선 코드부터 치면서 마구잡이로 짜는 것이 개발 속도를 높일 수가 있다.
하지만 유지보수, 기능 추가 등의 작업이 이루어질 때 새로운 기능을 추가해야할 지점과 어떻게 고칠지를 쉽게 알 수 있다.
모듈화가 잘 되어있다면 전체 코드 중 모듈화부분만 살펴보면 되기 때문이다.
리팩터링이 잘 수행된 코드는 새로운 기능을 구축하는데  튼튼한 토대가 되고 본인, 타인이 언제 읽어도 쉽게 이해될 수 있는 코드가 된다.
1. **변수나 함수의 정확한 네이밍이 필요하다.**
예를 들어 비밀번호를 담는 변수가 어느곳에선 pw, 어느곳에선 password, passWord 로 쓰이고, 검증하는 함수가 어디서는 check, 어디서는 validate가 된다면 며칠만 지나도 본인조차 알아보기 힘들 것이다.
이들을 통일하는 것이 가독성을 증가시키고 생산성을 올릴 수 있다.
1. **함수 하나당 최소한의 기능으로 분할해야 한다.**
만약 회원가입 데이터를 검증하는 함수에서 모든 조건을 함수 한번에 담는다면 유지보수가 힘들고, 확장하기도 불리하며 테스트를 할때 문제를 직면할 확률이 높다.
함수당 하나의 조건으로 나누는 것이 직관적으로 알아보기도 좋고, 다른 함수를 추가하기도 용이하며 테스트코드의 작성또한 독립적으로 시행되어 오류를 줄일 수 있을 것이다.

>### B+트리? B-트리?
B-트리는 각 노드는 여러개의 key를 가질 수 있으며 여러개의 Child를 가질 수 있다. 또한 모든 리프 노드는 동일한 depth를 가지고 있다. 키는 B-트리 알고리즘에 따라 정렬되어 각 노드에 배치
각 노드는 최대 2개의 key를 가지며 최대 3개의 자식을 가질수 있다.
각 노드에는 여러개의 키를 갖고 키에 대응하는 데이터도 함께 갖는다. 하나의 노드에 여러개의 키를 갖는다.
B+트리는 b-트리를 개량한 트리로 b-트리처럼 모든 리프 노드에 동일한 depth를 가지지만 b+ 트리는 inner 노드에는 키만 저장이 되고 리프 노드에는 키와 데이터를 함께 저장한다는 것이다. 리프 노드에만 데이터가 저장되기 때문에 리프간의 포인트를 연결 b-트리에 비해 쉬운 순회가 가능 inner Node에는 데이터가 없기때문에 b-트리의 inner 노드에 비해 용량이 작아 많은 inner노드의 배치가 가능하다.
B+tree의 장점 1. 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용할 수 있다. 하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.(cache hit를 높일 수 있음) 2. 풀 스캔 시, B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다

![](https://images.velog.io/images/changchanghwang/post/20455c8d-402d-4e4d-a40d-9b5eb9329096/image.png)
>b-tree

![](https://images.velog.io/images/changchanghwang/post/e6fa155a-4336-490d-9d79-e7a289d5f97b/image.png)
>b+tree

>### **JOI의 정의와 장점**
Joi는 object schema description language라고 하며 클라이언트 및 서버측 유효성 검사에 모두 사용할수 있는 유효성 검사 라이브러리이다. 
Validation을 할때 관계에 따른 내용을 정의 할수 있다. 
Joi의 가장 큰 장점은 유용성입니다. 사용하기 쉽고 확장하기 쉬우며 JavaScript의 모든 기능을 갖추고 있습니다.
단점은 프론트 엔드에서 검증 로직을 재사용하려면 백엔드에서 언어를 선택해야 한다는 것입니다.
Node.js에서 리팩토링시 사용하며, npm을 통해 다운로드 했던 모듈을 불러오는 require 함수는 어떻게 동작하나요? IIFE와 연결지어 찾아보고 정리해보세요.


튜터님이 해주신 답변

>### HTTP/HTTPS 프로토콜이 아닌 gRPC 프로토콜로 통신하는 서버 프로그램은 API 서버라고 부를 수 있을까요? (배포된 환경, 구현된 기능은 동일)
- Answer
    - 가능하다. HTTP/HTTPS가 브라우저에서도 지원하고 범용적이기 때문에 지원하는 API 서버가 일반적일 뿐, 서버와 서버 간으로 gRPC 프로토콜을 이용해 API를 호출하여 제 기능을 다 할 수 있다.

> ### Sequlize같은 ORM과 MySQL같은 데이터베이스의 차이가 무엇인가요?
- Answer
    - ORM은 데이터베이스가 지원하는 데이터 구조를 통해 추상화 레벨을 높이는 역할
    - 데이터베이스는 특정 목적성을 가진채 데이터를 더 빠르고 정확하게 관리하도록 돕는 역할
        - 때문에 경우에 따라서 AWS S3와 같은 Object Storage도 데이터베이스의 용도로서 사용 가능하다. (Use case에 따라 적합하지 않을 수 있음)

>### express.js의 라우터는 미들웨어입니다. 어떤 원리로 동작하기 때문에 미들웨어로 라우터를 구현할 수 있나요?
- Answer
    - 미들웨어의 원리를 제대로 이해하고 있다면 당연. 기본적으로 라우터를 사용하지 않고, express의 내부 라우터를 사용하지 않는 경우 아래와 같이 구현하는것과 크게 다르지 않음.
    
    ```
    app.use((req, res) => {
    	if (req.method !== 'GET' || req.path !== '/users/me') {
    		res.status(404).end();
    	}
    
    	// logic...
    	const result = getUserByToken(token);
    
    	res.send(result).end();
    });
    ```
    

>### Node.js에서 리팩토링시 사용하며, npm을 통해 다운로드 했던 모듈을 불러오는 require 함수는 어떻게 동작하나요? IIFE와 연결지어 찾아보고 정리해보세요.
- Answer
    - [https://m.blog.naver.com/jdub7138/221022257248](https://m.blog.naver.com/jdub7138/221022257248)
    - 모듈은 IIFE를 통해 encapsulation되어 호출됩니다.
    (예전에는 IIFE를 통해 캡슐화를 지원 했지만 지금은 내부 모듈 시스템에 의해 알아서 캡슐화가 됩니다.)

>### 불필요한 테스트코드는 무엇이며, 100개의 테스트 케이스보다 1개의 테스트 케이스가 더 효과적일 수 있는 이유는 무엇인가요?
- Answer
    - 의도치 않게 Input or Output이 바뀌었을 때 검증할 수 없는 테스트코드는 불필요한 테스트코드
    - 이러한 테스트코드가 100개 있는것보다 Input, Output의 검증을 명확히 하는 테스트 코드 1개 있는게 테스트코드의 목적성에도 걸맞으며 훨씬 효과적인 테스트코드로 볼 수 있다.